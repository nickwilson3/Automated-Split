<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Edit Jury Assignments</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.0/dist/css/bootstrap.min.css">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
    <!-- Include Bootstrap Icons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css">
</head>
<body>
    <div class="container-fluid mt-3">
        <div class="row">
            <div class="col-md-12">
                <div class="card">
                    <div class="card-header text-center">
                        <h2>Edit Jury Assignments</h2>
                    </div>
                    <div class="card-body">
                        {% with messages = get_flashed_messages() %}
                            {% if messages %}
                                {% for message in messages %}
                                    <div class="alert alert-danger">{{ message }}</div>
                                {% endfor %}
                            {% endif %}
                        {% endwith %}
                        
                        <div class="alert alert-info">
                            <p><strong>Instructions:</strong> You can edit jury assignments by changing the jury number in the dropdown menu for each juror. When you're satisfied with the assignments, click "Confirm Final Split" to generate the final report.</p>
                        </div>
                        
                        <!-- Tabular Scoreboard Section -->
                        <div class="scoreboard mb-4">
                            <h3 class="mb-3">Jury Summary</h3>
                            <div class="table-responsive">
                                <table class="table table-bordered" id="scoreboard-table">
                                    <thead id="scoreboard-header">
                                        <!-- Headers will be generated dynamically -->
                                    </thead>
                                    <tbody id="scoreboard-body">
                                        <!-- Rows will be generated dynamically -->
                                    </tbody>
                                </table>
                            </div>
                        </div>
                        
                        <div class="row mb-3">
                            <div class="col-md-4">
                                <label for="filter-jury" class="form-label">Filter by Jury:</label>
                                <select class="form-select" id="filter-jury">
                                    <option value="all">Show All Juries</option>
                                    <option value="Unassigned">Unassigned</option>
                                    {% for jury in juries %}
                                    <option value="{{ jury }}">Jury {{ jury_letter(jury) }}</option>
                                    {% endfor %}
                                </select>
                            </div>
                            <div class="col-md-4">
                                <label for="filter-leaning" class="form-label">Filter by Leaning:</label>
                                <select class="form-select" id="filter-leaning">
                                    <option value="all">Show All Leanings</option>
                                    <option value="P">P</option>
                                    <option value="P+">P+</option>
                                    <option value="D">D</option>
                                    <option value="D+">D+</option>
                                </select>
                            </div>
                        </div>
                        
                        <div class="table-responsive">
                            <table class="table table-striped table-bordered" id="assignments-table">
                                <thead>
                                    <tr>
                                        <th>Jury</th>
                                        <th>Name</th>
                                        <th>Leaning</th>
                                        <th>Gender</th>
                                        <th>Race</th>
                                        <th>Age</th>
                                        <th>Education</th>
                                        <th>Marital Status</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {% for juror in assignments %}
                                    <tr data-jury="{{ juror.jury }}" data-leaning="{{ juror.Final_Leaning }}">
                                        <td>
                                            <select class="form-select jury-select" data-juror-index="{{ loop.index0 }}">
                                                <option value="Unassigned" {% if juror.jury == 'Unassigned' %}selected{% endif %}>Unassigned</option>
                                                {% for jury in juries %}
                                                <option value="{{ jury }}" {% if jury == juror.jury %}selected{% endif %}>{{ jury_letter(jury) }}</option>
                                                {% endfor %}
                                            </select>
                                        </td>
                                        <td>{{ juror.Name }}</td>
                                        <td {% if juror.Final_Leaning in ['P', 'P+'] %}class="text-primary"{% else %}class="text-danger"{% endif %}>
                                            {{ juror.Final_Leaning }}
                                        </td>
                                        <td>{{ juror.Gender }}</td>
                                        <td>{{ juror.Race }}</td>
                                        <td>{{ juror.Age }}</td>
                                        <td>{{ juror.Education }}</td>
                                        <td>{{ juror.Marital }}</td>
                                    </tr>
                                    {% endfor %}
                                </tbody>
                            </table>
                        </div>
                        
                        <div class="mt-4 d-flex justify-content-between">
                            <button id="save-changes" class="btn btn-primary">Save Changes</button>
                            <button id="confirm-split-btn" class="btn btn-primary">Confirm Final Split</button>
                            <form action="{{ url_for('generate_report') }}" method="post" id="generate-report-form">
                                <!-- Hidden form - will be submitted via JavaScript -->
                            </form>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Warning Modal -->
    <div class="modal fade" id="warningModal" tabindex="-1" aria-labelledby="warningModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header bg-warning">
                    <h5 class="modal-title" id="warningModalLabel">Warning: Jury Assignment Issues</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body" id="warning-message">
                    <!-- Warning messages will be inserted here dynamically -->
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" id="go-back-btn">Go Back</button>
                    <button type="button" class="btn btn-warning" id="proceed-anyway">Proceed Anyway</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.0/dist/js/bootstrap.bundle.min.js"></script>

    <script id="assignments-data" type="application/json">
        {{ assignments|tojson }}
    </script>
    <script type="text/javascript">
        // Target jury size from backend
        const targetJurySize = {{ jury_size }};
    </script>
    
    <script>
        // Function to check for jury assignment issues
        // This JavaScript should replace the existing script section in edit.html
        // after the assignments-data script tag (keep that tag)

        document.addEventListener('DOMContentLoaded', function() {
            console.log('Edit page script loaded');
            
            // Store the assignments data
            const assignmentsData = JSON.parse(document.getElementById('assignments-data').textContent);
            
            // Create a deep copy of the original data to track changes
            const originalAssignmentsData = JSON.parse(JSON.stringify(assignmentsData));

            // Track if changes have been saved
            let changesSaved = true;
            
            // Use the target jury size from the backend
            // const targetJurySize = {{ jury_size }}; // This should be defined earlier in a separate script tag
            
            // Initialize the warning modal
            const warningModal = new bootstrap.Modal(document.getElementById('warningModal'));
            
            // Initialize the scoreboard
            updateScoreboard();
            
            // Filter functionality
            document.getElementById('filter-jury').addEventListener('change', filterTable);
            document.getElementById('filter-leaning').addEventListener('change', filterTable);
            
            function filterTable() {
                const juryFilter = document.getElementById('filter-jury').value;
                const leaningFilter = document.getElementById('filter-leaning').value;

                const juryFilterStr = String(juryFilter);
                const leaningFilterStr = String(leaningFilter);
                
                const rows = document.querySelectorAll('#assignments-table tbody tr');
                
                rows.forEach(row => {
                    const jury = row.getAttribute('data-jury');
                    const leaning = row.getAttribute('data-leaning');
                    
                    const juryMatch = juryFilter === 'all' || jury === juryFilter;
                    const leaningMatch = leaningFilter === 'all' || leaning === leaningFilter;
                    
                    if (juryMatch && leaningMatch) {
                        row.style.display = '';
                    } else {
                        row.style.display = 'none';
                    }
                });
            }
            
            // Calculate optimal distribution using maximin approach
            function calculateOptimalDistribution(totalCount, numGroups) {
                // Base distribution - start by dividing evenly
                const baseValue = Math.floor(totalCount / numGroups);
                
                // Calculate how many groups need to get an extra resource
                const remainder = totalCount % numGroups;
                
                // Create the distribution: some groups get (base_value + 1), the rest get base_value
                return Array(remainder).fill(baseValue + 1).concat(Array(numGroups - remainder).fill(baseValue));
            }
            
            // Function to determine if a jury has optimal P/D balance
            function hasOptimalPDBalance(pCount, dCount, jurySize) {
                const totalSize = pCount + dCount;
                
                // If jury isn't full, it's not optimal
                if (totalSize < jurySize) return false;
                
                // For even jury sizes, ideal is 50/50
                if (jurySize % 2 === 0) {
                    const idealP = jurySize / 2;
                    return Math.abs(pCount - idealP) <= 1;
                } 
                // For odd jury sizes, either P or D can have one extra
                else {
                    const idealP1 = Math.floor(jurySize / 2);
                    const idealP2 = Math.ceil(jurySize / 2);
                    return pCount === idealP1 || pCount === idealP2;
                }
            }
            
            function checkJuryIssues() {
                const issues = [];
                const juryStats = {};
                
                // Get unique juries (excluding Unassigned)
                const juries = [...new Set(assignmentsData.map(juror => juror.jury))]
                    .filter(jury => jury !== 'Unassigned')
                    .sort((a, b) => {
                        // Convert numeric juries to letters for comparison
                        const juryA = isNaN(a) ? a : String.fromCharCode(64 + parseInt(a));
                        const juryB = isNaN(b) ? b : String.fromCharCode(64 + parseInt(b));
                        return juryA.localeCompare(juryB);
                    });
                
                // Count all jurors by leaning, including unassigned
                let totalP = 0;
                let totalD = 0;
                
                // First gather stats for all jurors including unassigned
                const allJurors = assignmentsData.filter(juror => juror.Final_Leaning);
                totalP = allJurors.filter(j => ['P', 'P+'].includes(j.Final_Leaning)).length;
                totalD = allJurors.filter(j => ['D', 'D+'].includes(j.Final_Leaning)).length;
                
                // Then gather stats for each jury
                juries.forEach(jury => {
                    const jurors = assignmentsData.filter(juror => juror.jury === jury);
                    const pCount = jurors.filter(j => ['P', 'P+'].includes(j.Final_Leaning)).length;
                    const dCount = jurors.filter(j => ['D', 'D+'].includes(j.Final_Leaning)).length;
                    
                    // Store counts for each jury
                    juryStats[jury] = { 
                        total: jurors.length,
                        pCount: pCount,
                        dCount: dCount
                    };
                });
                
                // Calculate optimal targets based on total available jurors
                const calculateOptimalTargets = () => {
                    // Each jury should ideally have exactly targetJurySize jurors
                    const numJuries = juries.length;
                    
                    // Case where we can satisfy all juries with perfect size
                    if (totalP + totalD >= numJuries * targetJurySize) {
                        // We need to distribute D jurors optimally while ensuring each jury has exactly targetJurySize jurors
                        // Calculate optimal D distribution
                        const optimalDDistribution = calculateOptimalDistribution(Math.min(totalD, numJuries * targetJurySize), numJuries);
                        
                        // For each jury, P count should be (targetJurySize - D count)
                        const optimalPDistribution = optimalDDistribution.map(d => targetJurySize - d);
                        
                        return {
                            optimalPDistribution,
                            optimalDDistribution
                        };
                    } 
                    // Case where we don't have enough jurors to fill all juries
                    else {
                        // In this case, we should distribute all available jurors
                        // First, figure out how many complete juries we can make
                        const completeJuries = Math.floor((totalP + totalD) / targetJurySize);
                        
                        // If we can't even make one complete jury, just distribute what we have
                        if (completeJuries < 1) {
                            const optimalDDistribution = calculateOptimalDistribution(totalD, numJuries);
                            const optimalPDistribution = juries.map((_, i) => {
                                // Ensure we don't exceed targetJurySize
                                return Math.min(targetJurySize - (optimalDDistribution[i] || 0), 
                                    Math.ceil(totalP / numJuries));
                            });
                            
                            return {
                                optimalPDistribution,
                                optimalDDistribution
                            };
                        }
                        
                        // If we can make some complete juries but not all
                        // First, distribute D optimally among complete juries
                        const dForCompleteJuries = Math.min(totalD, completeJuries * targetJurySize);
                        const optimalDForComplete = calculateOptimalDistribution(dForCompleteJuries, completeJuries);
                        
                        // Then calculate P for complete juries
                        const optimalPForComplete = optimalDForComplete.map(d => targetJurySize - d);
                        
                        // Now handle remaining juries
                        const remainingD = totalD - dForCompleteJuries;
                        const remainingP = totalP - optimalPForComplete.reduce((sum, p) => sum + p, 0);
                        
                        // Distribute remaining jurors
                        const remainingJuries = numJuries - completeJuries;
                        const optimalDForRemaining = remainingJuries > 0 
                            ? calculateOptimalDistribution(remainingD, remainingJuries) 
                            : [];
                            
                        const optimalPForRemaining = remainingJuries > 0 
                            ? calculateOptimalDistribution(remainingP, remainingJuries)
                            : [];
                        
                        // Combine the distributions
                        const optimalDDistribution = [...optimalDForComplete, ...optimalDForRemaining];
                        const optimalPDistribution = [...optimalPForComplete, ...optimalPForRemaining];
                        
                        return {
                            optimalPDistribution,
                            optimalDDistribution
                        };
                    }
                };
                
                const { optimalPDistribution, optimalDDistribution } = calculateOptimalTargets();
                
                // Second pass: check each jury against its targets
                juries.forEach((jury, index) => {
                    const stats = juryStats[jury];
                    
                    // Convert numeric jury to letter for display
                    let juryLabel;
                    if (!isNaN(jury)) {
                        juryLabel = String.fromCharCode(64 + parseInt(jury)); // Convert 1 to A, 2 to B, etc.
                    } else {
                        juryLabel = jury;
                    }
                    
                    // Check jury size
                    if (stats.total !== targetJurySize) {
                        issues.push(`Jury ${juryLabel} has ${stats.total} jurors (target is ${targetJurySize}).`);
                    }
                    
                    // Use targets for this jury from the optimal distribution
                    // But only if we have enough index values in our distributions
                    if (index < optimalPDistribution.length && index < optimalDDistribution.length) {
                        const targetP = optimalPDistribution[index];
                        const targetD = optimalDDistribution[index];
                        
                        // Store targets for reference
                        juryStats[jury].targetP = targetP;
                        juryStats[jury].targetD = targetD;
                        
                        // Check P/D balance against optimal targets only if total is correct
                        if (stats.pCount !== targetP || stats.dCount !== targetD) {
                            issues.push(`Jury ${juryLabel} has a P/D balance of ${stats.pCount}:${stats.dCount}, but the optimal balance is ${targetP}:${targetD}.`);
                        }
                    }
                });
                
                // Track unassigned jurors
                const unassignedJurors = assignmentsData.filter(juror => juror.jury === 'Unassigned');
                const unassignedCount = unassignedJurors.length;
                const unassignedP = unassignedJurors.filter(j => ['P', 'P+'].includes(j.Final_Leaning)).length;
                const unassignedD = unassignedJurors.filter(j => ['D', 'D+'].includes(j.Final_Leaning)).length;
                
                juryStats['unassigned'] = { 
                    count: unassignedCount,
                    pCount: unassignedP,
                    dCount: unassignedD
                };
                
                // Add information about the overall optimal distribution to the response
                return {
                    hasIssues: issues.length > 0,
                    issues: issues,
                    juryStats: juryStats,
                    unassignedCount: unassignedCount,
                    optimalPDistribution: optimalPDistribution,
                    optimalDDistribution: optimalDDistribution,
                    totalP: totalP,
                    totalD: totalD
                };
            }
            
            // Function to update the scoreboard
            function updateScoreboard() {
                console.log("Updating scoreboard...");
                
                // Get unique juries (excluding Unassigned)
                const juries = [...new Set(assignmentsData.map(juror => juror.jury))]
                    .filter(jury => jury !== 'Unassigned')
                    .sort((a, b) => {
                        // Convert numeric juries to letters for comparison
                        const juryA = isNaN(a) ? a : String.fromCharCode(64 + parseInt(a));
                        const juryB = isNaN(b) ? b : String.fromCharCode(64 + parseInt(b));
                        
                        return juryA.localeCompare(juryB);
                    });
                
                // Add Unassigned at the end if it exists
                if (assignmentsData.some(juror => juror.jury === 'Unassigned')) {
                    juries.push('Unassigned');
                }
                
                // First pass to collect all unique demographic values
                const uniqueDemographics = {
                    gender: new Set(),
                    race: new Set(),
                    ageGroup: new Set(),
                    education: new Set()
                };
                
                assignmentsData.forEach(juror => {
                    if (juror.Gender) uniqueDemographics.gender.add(juror.Gender);
                    if (juror.Race) uniqueDemographics.race.add(juror.Race);
                    
                    // Handle age groups
                    if (juror.AgeGroup) {
                        uniqueDemographics.ageGroup.add(juror.AgeGroup);
                    } else if (juror.Age) {
                        let ageGroup;
                        const age = parseInt(juror.Age);
                        if (age < 30) ageGroup = '<30';
                        else if (age < 40) ageGroup = '30-39';
                        else if (age < 50) ageGroup = '40-49';
                        else if (age < 60) ageGroup = '50-59';
                        else ageGroup = '60+';
                        
                        uniqueDemographics.ageGroup.add(ageGroup);
                    }
                    
                    if (juror.Education) uniqueDemographics.education.add(juror.Education);
                });
                
                // Second pass to calculate stats for each jury
                const juryStats = {};
                
                juries.forEach(jury => {
                    const jurors = assignmentsData.filter(juror => juror.jury === jury);
                    
                    // Initialize stats
                    juryStats[jury] = {
                        total: jurors.length,
                        leaning: { 'P': 0, 'P+': 0, 'D': 0, 'D+': 0 },
                        gender: {},
                        race: {},
                        ageGroup: {},
                        education: {}
                    };
                    
                    // Initialize counters for each demographic value
                    uniqueDemographics.gender.forEach(value => juryStats[jury].gender[value] = 0);
                    uniqueDemographics.race.forEach(value => juryStats[jury].race[value] = 0);
                    uniqueDemographics.ageGroup.forEach(value => juryStats[jury].ageGroup[value] = 0);
                    uniqueDemographics.education.forEach(value => juryStats[jury].education[value] = 0);
                    
                    // Count demographics
                    jurors.forEach(juror => {
                        // Count leaning
                        if (juror.Final_Leaning) {
                            juryStats[jury].leaning[juror.Final_Leaning] = 
                                (juryStats[jury].leaning[juror.Final_Leaning] || 0) + 1;
                        }
                        
                        // Count gender
                        if (juror.Gender) {
                            juryStats[jury].gender[juror.Gender] += 1;
                        }
                        
                        // Count race
                        if (juror.Race) {
                            juryStats[jury].race[juror.Race] += 1;
                        }
                        
                        // Count age groups
                        if (juror.AgeGroup) {
                            juryStats[jury].ageGroup[juror.AgeGroup] += 1;
                        } else if (juror.Age) {
                            let ageGroup;
                            const age = parseInt(juror.Age);
                            if (age < 30) ageGroup = '<30';
                            else if (age < 40) ageGroup = '30-39';
                            else if (age < 50) ageGroup = '40-49';
                            else if (age < 60) ageGroup = '50-59';
                            else ageGroup = '60+';
                            
                            juryStats[jury].ageGroup[ageGroup] += 1;
                        }
                        
                        // Count education
                        if (juror.Education) {
                            juryStats[jury].education[juror.Education] += 1;
                        }
                    });
                });
                
                // Generate table headers
                const headerRow = document.createElement('tr');
                headerRow.innerHTML = `
                    <th>Jury</th>
                    <th>Size</th>
                    <th>P/D Balance</th>
                `;
                
                // Add headers for gender
                uniqueDemographics.gender.forEach(gender => {
                    headerRow.innerHTML += `<th>${gender}</th>`;
                });
                
                // Add headers for race
                uniqueDemographics.race.forEach(race => {
                    // Abbreviate long names
                    const displayRace = race.length > 8 ? race.substring(0, 7) + '.' : race;
                    headerRow.innerHTML += `<th>${displayRace}</th>`;
                });
                
                // Add headers for age groups (sort them first)
                const ageOrder = ['<30', '30-39', '40-49', '50-59', '60+'];
                const sortedAgeGroups = [...uniqueDemographics.ageGroup]
                    .sort((a, b) => ageOrder.indexOf(a) - ageOrder.indexOf(b));
                
                sortedAgeGroups.forEach(ageGroup => {
                    headerRow.innerHTML += `<th>${ageGroup}</th>`;
                });
                
                // Add headers for education (alphabetical)
                const sortedEducation = [...uniqueDemographics.education].sort();
                sortedEducation.forEach(edu => {
                    // Abbreviate long names
                    const displayEdu = edu.length > 8 ? edu.substring(0, 7) + '.' : edu;
                    headerRow.innerHTML += `<th>${displayEdu}</th>`;
                });
                
                // Set the table header
                const scoreboardHeader = document.getElementById('scoreboard-header');
                scoreboardHeader.innerHTML = '';
                scoreboardHeader.appendChild(headerRow);
                
                // Generate table rows
                const scoreboardBody = document.getElementById('scoreboard-body');
                scoreboardBody.innerHTML = '';
                
                // First, check jury assignment issues to get optimal distribution
                const juryIssues = checkJuryIssues();
                
                for (const jury of juries) {
                    const stats = juryStats[jury];
                    
                    // Calculate P/D balance
                    const pTotal = (stats.leaning['P'] || 0) + (stats.leaning['P+'] || 0);
                    const dTotal = (stats.leaning['D'] || 0) + (stats.leaning['D+'] || 0);
                    
                    // Determine if jury is balanced (size and P/D)
                    const hasCorrectSize = jury === 'Unassigned' || stats.total === targetJurySize;
                    
                    // If this is an actual jury (not unassigned), check against the optimal distribution
                    let hasGoodBalance = true;
                    let optimalP = null;
                    let optimalD = null;
                    
                    if (jury !== 'Unassigned' && juryIssues.juryStats[jury]) {
                        optimalP = juryIssues.juryStats[jury].targetP;
                        optimalD = juryIssues.juryStats[jury].targetD;
                        hasGoodBalance = (pTotal === optimalP && dTotal === optimalD);
                    } else if (jury !== 'Unassigned') {
                        // Fallback to original balance check if jury isn't in the stats
                        hasGoodBalance = hasOptimalPDBalance(pTotal, dTotal, targetJurySize);
                    }
                    
                    const isOptimal = hasCorrectSize && hasGoodBalance;
                    
                    // Convert numeric jury to letter
                    let juryLabel;
                    if (jury === 'Unassigned') {
                        juryLabel = 'Unassigned';
                    } else if (!isNaN(jury)) {
                        juryLabel = String.fromCharCode(64 + parseInt(jury)); // Convert 1 to A, 2 to B, etc.
                    } else {
                        juryLabel = jury;
                    }
                    
                    const row = document.createElement('tr');
                    if (jury === 'Unassigned') {
                        row.className = 'table-light';
                    } else if (isOptimal) {
                        row.className = 'table-success';
                    } else {
                        row.className = 'table-danger';
                    }
                    
                    // Build basic columns
                    let rowHtml = `
                        <td><strong>${juryLabel}</strong></td>
                        <td>${stats.total}${!hasCorrectSize && jury !== 'Unassigned' ? ` <span title="Target: ${targetJurySize}">⚠️</span>` : ''}</td>
                        <td>${pTotal}P / ${dTotal}D${optimalP !== null && !hasGoodBalance && jury !== 'Unassigned' ? 
                            ` <span title="Optimal: ${optimalP}P / ${optimalD}D">⚠️</span>` : ''}</td>
                    `;
                    
                    // Add gender columns
                    uniqueDemographics.gender.forEach(gender => {
                        rowHtml += `<td>${stats.gender[gender] || 0}</td>`;
                    });
                    
                    // Add race columns
                    uniqueDemographics.race.forEach(race => {
                        rowHtml += `<td>${stats.race[race] || 0}</td>`;
                    });
                    
                    // Add age group columns
                    sortedAgeGroups.forEach(ageGroup => {
                        rowHtml += `<td>${stats.ageGroup[ageGroup] || 0}</td>`;
                    });
                    
                    // Add education columns
                    sortedEducation.forEach(edu => {
                        rowHtml += `<td>${stats.education[edu] || 0}</td>`;
                    });
                    
                    row.innerHTML = rowHtml;
                    scoreboardBody.appendChild(row);
                }
                
                console.log("Scoreboard updated successfully.");
            }
            
            // Function to check if there are unsaved changes
            function hasUnsavedChanges() {
                // Compare current assignments with original assignments
                return assignmentsData.some((juror, index) => {
                    return juror.jury !== originalAssignmentsData[index].jury;
                });
            }
            
            // Handle jury selection change
            document.querySelectorAll('.jury-select').forEach(select => {
                select.addEventListener('change', function() {
                    const jurorIndex = parseInt(this.getAttribute('data-juror-index'));
                    const newJury = this.value;
                    
                    console.log(`Changing juror ${jurorIndex} to jury ${newJury}`);
                    
                    // Update the row's data attribute for filtering
                    this.closest('tr').setAttribute('data-jury', newJury);
                    
                    // Update the assignments data
                    assignmentsData[jurorIndex].jury = newJury;
                    
                    // Mark changes as unsaved
                    changesSaved = false;
                    
                    // Update the scoreboard
                    updateScoreboard();
                });
            });
            
            // Save changes button
            document.getElementById('save-changes').addEventListener('click', function() {
                console.log('Save button clicked');
                
                // Don't send request if no changes
                if (!hasUnsavedChanges()) {
                    alert('No changes to save.');
                    return;
                }
                
                // Send data to server
                fetch('/save_edits', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(assignmentsData)
                })
                .then(response => {
                    console.log('Response received', response);
                    return response.json();
                })
                .then(data => {
                    console.log('Data received', data);
                    if (data.status === 'success') {
                        // Mark changes as saved
                        changesSaved = true;
                        
                        // Update our original data copy to match current state
                        Object.assign(originalAssignmentsData, JSON.parse(JSON.stringify(assignmentsData)));
                        
                        alert('Changes saved successfully');
                    } else {
                        alert('Error saving changes: ' + data.message);
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                    alert('Error saving changes. Please try again.');
                });
            });
            
            // Setup modal button event handlers
            const goBackBtn = document.getElementById('go-back-btn');
            const proceedAnywayBtn = document.getElementById('proceed-anyway');
            
            // Default go back button behavior
            goBackBtn.addEventListener('click', function() {
                warningModal.hide();
            });
            
            // Default proceed anyway button behavior
            proceedAnywayBtn.addEventListener('click', function() {
                warningModal.hide();
                document.getElementById('generate-report-form').submit();
            });
            
            // Function to check jury balance issues (extracted to avoid code duplication)
            function checkJuryBalanceIssues() {
                // Reset modal buttons to default text
                proceedAnywayBtn.textContent = 'Proceed Anyway';
                goBackBtn.textContent = 'Go Back';
                
                // Temporarily remove click handlers to avoid conflicts
                proceedAnywayBtn.onclick = null;
                goBackBtn.onclick = null;
                
                // Add new click handlers specific to balance issues
                proceedAnywayBtn.onclick = function() {
                    warningModal.hide();
                    document.getElementById('generate-report-form').submit();
                };
                
                goBackBtn.onclick = function() {
                    warningModal.hide();
                };
                
                // Check for issues with jury assignments
                const checkResult = checkJuryIssues();
                
                if (checkResult.hasIssues) {
                    // Show warning modal with issues
                    const warningMessage = document.getElementById('warning-message');
                    warningMessage.innerHTML = `
                        <p>The following issues were found with your jury assignments:</p>
                        <ul class="text-danger">
                            ${checkResult.issues.map(issue => `<li>${issue}</li>`).join('')}
                        </ul>
                        <p>Do you want to proceed anyway or go back and make adjustments?</p>
                    `;
                    warningModal.show();
                } else {
                    // No issues, submit the form directly
                    document.getElementById('generate-report-form').submit();
                }
            }
            
            // Confirm final split button
            document.getElementById('confirm-split-btn').addEventListener('click', function() {
                console.log('Confirm final split button clicked');
                
                // Check for unsaved changes first
                if (hasUnsavedChanges() && !changesSaved) {
                    // Show unsaved changes warning
                    const warningMessage = document.getElementById('warning-message');
                    warningMessage.innerHTML = `
                        <p class="text-warning"><i class="bi bi-exclamation-triangle-fill"></i> <strong>You have unsaved changes to your jury assignments.</strong></p>
                        <p>If you proceed without saving, these changes may not be reflected in your final report.</p>
                        <p>Would you like to save your changes first?</p>
                    `;
                    
                    // Change modal buttons
                    proceedAnywayBtn.textContent = 'Proceed Without Saving';
                    goBackBtn.textContent = 'Save Changes First';
                    
                    // Temporarily remove click handlers to avoid conflicts
                    proceedAnywayBtn.onclick = null;
                    goBackBtn.onclick = null;
                    
                    // Set different actions for unsaved changes warning
                    proceedAnywayBtn.onclick = function() {
                        warningModal.hide();
                        checkJuryBalanceIssues();
                    };
                    
                    goBackBtn.onclick = function() {
                        warningModal.hide();
                        document.getElementById('save-changes').click();
                        // We'll need to wait a bit for the save to complete
                        setTimeout(checkJuryBalanceIssues, 1000);
                    };
                    
                    warningModal.show();
                } else {
                    // No unsaved changes, proceed to check for jury balance issues
                    checkJuryBalanceIssues();
                }
            });
        });
    </script>
</body>
</html>